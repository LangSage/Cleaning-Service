@file:OptIn(androidx.compose.material3.ExperimentalMaterial3Api::class)

package com.example.cadence_app

import android.Manifest
import android.annotation.SuppressLint
import android.app.NotificationChannel
import android.app.NotificationManager
import android.bluetooth.*
import android.bluetooth.le.*
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.AudioAttributes
import android.media.RingtoneManager
import android.os.*
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import com.example.cadence_app.ui.theme.Cadence_appTheme
import org.json.JSONArray
import org.json.JSONObject
import java.util.*
import kotlin.math.max
import kotlin.math.roundToInt

/* ---------- Prefs / channels ---------- */
private const val PREFS = "prefs"
private const val PREF_LAST_DEVICE = "last_device_address"
private const val PREF_SESSIONS = "sessions_json"   // stores a JSON array of sessions
private const val CHANNEL_SILENT = "CADENCE_CHANNEL_SILENT"
private const val CHANNEL_LOUD = "CADENCE_CHANNEL_LOUD"

/* ---------- Main Activity ---------- */
class MainActivity : ComponentActivity() {

    // BLE core
    private lateinit var bluetoothAdapter: BluetoothAdapter
    private var bluetoothGatt: BluetoothGatt? = null
    private var scanner: BluetoothLeScanner? = null
    private var scanCallback: ScanCallback? = null
    private val handler = Handler(Looper.getMainLooper())

    // GATT UUIDs
    private val CSC_SERVICE_UUID = UUID.fromString("00001816-0000-1000-8000-00805f9b34fb")
    private val CSC_MEASUREMENT_UUID = UUID.fromString("00002a5b-0000-1000-8000-00805f9b34fb")
    private val CCCD_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb")

    // Session state (non-Compose)
    private var sessionStart = 0L
    private var lastNonZeroTime = 0L
    private var alertArmed = true
    private var rpmHistory = mutableListOf<Pair<Long, Int>>() // (timestampMs, rawRpm)

    // Smoothing state
    private var lastSmoothed = 0.0
    private var lastDisplayTime = 0L

    // Continuous alert ticker
    private val alertHandler = Handler(Looper.getMainLooper())
    private var alertTickerRunning = false

    @SuppressLint("MissingPermission")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val manager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        bluetoothAdapter = manager.adapter
        if (!bluetoothAdapter.isEnabled) {
            startActivity(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE))
        }
        createNotificationChannels()

        setContent {
            Cadence_appTheme {
                // Compose state
                var hasPermissions by remember { mutableStateOf(false) }
                var scanning by remember { mutableStateOf(false) }
                var devices by remember { mutableStateOf(listOf<BluetoothDevice>()) }
                var connected by remember { mutableStateOf(false) }
                var status by remember { mutableStateOf("Not connected") }

                // Live RPM shown (smoothed)
                var displayRpm by remember { mutableStateOf(0) }

                // Settings
                var thresholdRpm by remember { mutableStateOf(90) }
                var idleTimeoutMin by remember { mutableStateOf(2) }
                var soundEnabled by remember { mutableStateOf(true) }
                var continuousAlerts by remember { mutableStateOf(true) } // NEW: every second while below
                var showSettings by remember { mutableStateOf(false) }

                // Training flow
                var trainingOver by remember { mutableStateOf(false) }

                RequestBlePermissions(
                    onGranted = { hasPermissions = true },
                    onDenied = { status = "Bluetooth permissions denied" }
                )

                // Auto-reconnect when ready
                LaunchedEffect(hasPermissions) {
                    if (hasPermissions) {
                        tryAutoReconnect(
                            onStatus = { status = it },
                            onRpmRaw = { raw ->
                                val now = System.currentTimeMillis()
                                val smoothed = smoothRpm(raw, now)
                                displayRpm = smoothed
                                onNewCadenceSample(
                                    rawRpm = raw,
                                    shownRpm = smoothed,
                                    threshold = thresholdRpm,
                                    soundEnabled = soundEnabled,
                                    continuousAlerts = continuousAlerts,
                                    trainingOverSetter = { trainingOver = it },
                                    idleTimeoutMinProvider = { idleTimeoutMin },
                                    statusSetter = { status = it }
                                )
                            },
                            onConnected = {
                                connected = true
                                status = "Connected. Receiving cadence…"
                                startSessionIfNeeded()
                            }
                        )
                    }
                }

                Surface(Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    Column(Modifier.fillMaxSize()) {
                        TopAppBar(
                            title = { Text(if (!connected) "Bluetooth Devices" else "Training") },
                            actions = {
                                IconButton(onClick = { showSettings = true }) {
                                    Icon(Icons.Default.Settings, contentDescription = "Settings")
                                }
                            }
                        )

                        when {
                            !hasPermissions -> Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                Text("Grant Bluetooth & Location permissions")
                            }

                            trainingOver -> TrainingSummary(
                                rpmHistory = loadLastSessionGraph(this@MainActivity),
                                onRestart = {
                                    trainingOver = false
                                    rpmHistory.clear()
                                    status = "Restarting…"
                                    startSessionIfNeeded()
                                }
                            )

                            connected -> LiveChartView(
                                rpmHistory = rpmHistory, // raw history, chart shows line + numbers
                                rpm = displayRpm,
                                status = status,
                                onFinish = {
                                    finishSessionAndSave()
                                    trainingOver = true
                                    status = "Training finished"
                                },
                                onDisconnect = {
                                    disconnect()
                                    stopContinuousAlertTicker()
                                    connected = false
                                    status = "Disconnected"
                                }
                            )

                            else -> ConnectMenu(
                                scanning = scanning,
                                devices = devices,
                                status = status,
                                onScanToggle = {
                                    if (!scanning) {
                                        devices = emptyList()
                                        startScan(
                                            onStatus = { status = it },
                                            onDeviceFound = { d ->
                                                if (devices.none { it.address == d.address })
                                                    devices = devices + d
                                            }
                                        )
                                        scanning = true
                                        handler.postDelayed({
                                            stopScan(); scanning = false
                                            status = "Scan finished (${devices.size} found)"
                                        }, 15_000)
                                    } else {
                                        stopScan(); scanning = false
                                        status = "Scan stopped"
                                    }
                                },
                                onDeviceSelected = { device ->
                                    stopScan()
                                    saveLastDevice(device.address)
                                    connectToDevice(
                                        device,
                                        onStatus = { status = it },
                                        onRpmRaw = { raw ->
                                            val now = System.currentTimeMillis()
                                            val smoothed = smoothRpm(raw, now)
                                            displayRpm = smoothed
                                            onNewCadenceSample(
                                                rawRpm = raw,
                                                shownRpm = smoothed,
                                                threshold = thresholdRpm,
                                                soundEnabled = soundEnabled,
                                                continuousAlerts = continuousAlerts,
                                                trainingOverSetter = { trainingOver = it },
                                                idleTimeoutMinProvider = { idleTimeoutMin },
                                                statusSetter = { status = it }
                                            )
                                        },
                                        onConnected = {
                                            connected = true
                                            status = "Connected. Receiving cadence…"
                                            startSessionIfNeeded()
                                        }
                                    )
                                }
                            )
                        }
                    }

                    if (showSettings) {
                        SettingsSheet(
                            threshold = thresholdRpm,
                            onThresholdChange = { thresholdRpm = it; alertArmed = true },
                            idleMinutes = idleTimeoutMin,
                            onIdleMinutesChange = { idleTimeoutMin = it },
                            soundEnabled = soundEnabled,
                            onSoundEnabledChange = { soundEnabled = it },
                            continuousAlerts = continuousAlerts,
                            onContinuousAlertsChange = { continuousAlerts = it; if (!it) stopContinuousAlertTicker() },
                            onClose = { showSettings = false }
                        )
                    }
                }
            }
        }
    }

    /* ---------- Smoothing / inertia ---------- */
    private fun smoothRpm(raw: Int, now: Long): Int {
        // Guard against brief zeros after start/traffic lights: hold for up to 3s since last non-zero.
        val effective = if (raw == 0 && now - lastNonZeroTime < 3_000L) {
            lastSmoothed.roundToInt().coerceAtLeast(0)
        } else raw

        // EWMA smoothing for display
        val alpha = 0.30
        lastSmoothed = if (lastDisplayTime == 0L) {
            effective.toDouble()
        } else {
            alpha * effective + (1 - alpha) * lastSmoothed
        }
        lastDisplayTime = now
        return lastSmoothed.roundToInt()
    }

    /* ---------- Training/session helpers ---------- */
    private fun startSessionIfNeeded() {
        if (sessionStart == 0L) {
            sessionStart = System.currentTimeMillis()
            lastNonZeroTime = sessionStart
            rpmHistory.clear()
            alertArmed = true
        }
    }

    private fun onNewCadenceSample(
        rawRpm: Int,
        shownRpm: Int,
        threshold: Int,
        soundEnabled: Boolean,
        continuousAlerts: Boolean,
        trainingOverSetter: (Boolean) -> Unit,
        idleTimeoutMinProvider: () -> Int,
        statusSetter: (String) -> Unit
    ) {
        val now = System.currentTimeMillis()
        rpmHistory.add(now to shownRpm)

        // "Activity" clock uses raw non-zero
        if (rawRpm > 0) lastNonZeroTime = now

        // Idle => end session
        val idleMs = idleTimeoutMinProvider() * 60_000L
        if (now - lastNonZeroTime >= idleMs) {
            finishSessionAndSave()
            trainingOverSetter(true)
            statusSetter("Training over (idle ≥ ${idleTimeoutMinProvider()} min)")
            return
        }

        // Alerts
        if (continuousAlerts) {
            if (shownRpm < threshold) startContinuousAlertTicker(shownRpm, soundEnabled)
            else stopContinuousAlertTicker()
        } else {
            sendOnceOnDrop(shownRpm, threshold, soundEnabled)
        }
    }

    private fun sendOnceOnDrop(current: Int, threshold: Int, soundEnabled: Boolean) {
        if (alertArmed && current < threshold) {
            postAlertNotification(current, soundEnabled)
            alertArmed = false
        }
        if (current >= threshold) alertArmed = true
    }

    private fun startContinuousAlertTicker(current: Int, sound: Boolean) {
        if (alertTickerRunning) return
        alertTickerRunning = true
        alertHandler.post(object : Runnable {
            override fun run() {
                postAlertNotification(current, sound)
                if (alertTickerRunning) alertHandler.postDelayed(this, 1_000L)
            }
        })
    }

    private fun stopContinuousAlertTicker() {
        alertTickerRunning = false
        alertHandler.removeCallbacksAndMessages(null)
    }

    private fun finishSessionAndSave() {
        try {
            saveSession(this, sessionStart, System.currentTimeMillis(), rpmHistory.toList())
        } catch (_: Exception) {}
        try { disconnect() } catch (_: Exception) {}
        stopContinuousAlertTicker()
        sessionStart = 0L
        lastDisplayTime = 0L
        lastSmoothed = 0.0
    }

    /* ---------- BLE: auto-reconnect ---------- */
    @SuppressLint("MissingPermission")
    private fun tryAutoReconnect(
        onStatus: (String) -> Unit,
        onRpmRaw: (Int) -> Unit,
        onConnected: () -> Unit
    ) {
        val last = getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .getString(PREF_LAST_DEVICE, null) ?: return
        val device = runCatching { bluetoothAdapter.getRemoteDevice(last) }.getOrNull() ?: return
        onStatus("Reconnecting to last device…")
        connectToDevice(device, onStatus, onRpmRaw, onConnected)
    }

    private fun saveLastDevice(address: String) {
        getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .edit().putString(PREF_LAST_DEVICE, address).apply()
    }

    /* ---------- BLE: scan ---------- */
    @SuppressLint("MissingPermission")
    private fun startScan(onStatus: (String) -> Unit, onDeviceFound: (BluetoothDevice) -> Unit) {
        scanner = bluetoothAdapter.bluetoothLeScanner
        val settings = ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build()
        scanCallback = object : ScanCallback() {
            override fun onScanResult(callbackType: Int, result: ScanResult) { onDeviceFound(result.device) }
            override fun onScanFailed(errorCode: Int) { onStatus("Scan failed: $errorCode") }
        }
        if (hasScanPermission()) {
            scanner?.startScan(null, settings, scanCallback)
            @Suppress("DEPRECATION")
            bluetoothAdapter.startLeScan { d, _, _ -> onDeviceFound(d) }
            onStatus("Scanning…")
        } else onStatus("Missing scan permission")
    }

    @SuppressLint("MissingPermission")
    private fun stopScan() {
        try { scanner?.stopScan(scanCallback) } catch (_: Exception) {}
        try { @Suppress("DEPRECATION") bluetoothAdapter.stopLeScan(null) } catch (_: Exception) {}
    }

    /* ---------- BLE: connect ---------- */
    @SuppressLint("MissingPermission")
    private fun connectToDevice(
        device: BluetoothDevice,
        onStatus: (String) -> Unit,
        onRpmRaw: (Int) -> Unit,
        onConnected: () -> Unit
    ) {
        onStatus("Connecting to ${device.name ?: device.address}…")
        device.connectGatt(this, false, object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                if (status != BluetoothGatt.GATT_SUCCESS) { onStatus("Connection error: $status"); return }
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    bluetoothGatt = gatt
                    onStatus("Connected. Discovering services…")
                    gatt.discoverServices()
                    onConnected()
                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                    onStatus("Disconnected")
                }
            }

            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                val svc = gatt.getService(CSC_SERVICE_UUID)
                val ch = svc?.getCharacteristic(CSC_MEASUREMENT_UUID)
                if (ch != null) {
                    gatt.setCharacteristicNotification(ch, true)
                    ch.getDescriptor(CCCD_UUID)?.let {
                        it.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                        gatt.writeDescriptor(it)
                    }
                } else onStatus("Cadence service not found")
            }

            override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
                if (characteristic.uuid == CSC_MEASUREMENT_UUID) {
                    val raw = parseCadenceCsc(characteristic.value)
                    onRpmRaw(raw)
                }
            }
        })
    }

    @SuppressLint("MissingPermission")
    private fun disconnect() { bluetoothGatt?.close(); bluetoothGatt = null }

    /* ---------- Cadence parser (unchanged) ---------- */
    private var lastRev: Int? = null
    private var lastTime: Int? = null
    private fun parseCadenceCsc(data: ByteArray): Int {
        if (data.isEmpty()) return 0
        val flags = data[0].toInt() and 0xFF
        val crankPresent = (flags and 0x02) != 0
        if (!crankPresent || data.size < 5) return 0
        val rev = ((data[2].toInt() and 0xFF) shl 8) or (data[1].toInt() and 0xFF)
        val time = ((data[4].toInt() and 0xFF) shl 8) or (data[3].toInt() and 0xFF)
        val rpm = if (lastRev != null && lastTime != null) {
            val dRev = (rev - lastRev!!).let { if (it < 0) it + 65536 else it }
            val dTime = (time - lastTime!!).let { if (it < 0) it + 65536 else it }
            if (dTime > 0) (dRev * 60 * 1024) / dTime else 0
        } else 0
        lastRev = rev; lastTime = time; return rpm
    }

    /* ---------- Notifications ---------- */
    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val silent = NotificationChannel(CHANNEL_SILENT, "Cadence (silent)", NotificationManager.IMPORTANCE_LOW)
            val soundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)
            val attrs = AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_NOTIFICATION_EVENT).build()
            val loud = NotificationChannel(CHANNEL_LOUD, "Cadence (alerts)", NotificationManager.IMPORTANCE_HIGH).apply {
                enableVibration(true); vibrationPattern = longArrayOf(0, 120); setSound(soundUri, attrs)
            }
            getSystemService(NotificationManager::class.java).apply {
                createNotificationChannel(silent); createNotificationChannel(loud)
            }
        }
    }

    private fun postAlertNotification(rpmNow: Int, soundEnabled: Boolean) {
        val ch = if (soundEnabled) CHANNEL_LOUD else CHANNEL_SILENT
        val builder = NotificationCompat.Builder(this, ch)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("Cadence low")
            .setContentText("$rpmNow RPM")
            .setPriority(if (soundEnabled) NotificationCompat.PRIORITY_HIGH else NotificationCompat.PRIORITY_LOW)
        with(NotificationManagerCompat.from(this)) {
            if (ActivityCompat.checkSelfPermission(this@MainActivity, Manifest.permission.POST_NOTIFICATIONS)
                == PackageManager.PERMISSION_GRANTED) {
                notify((System.currentTimeMillis() % Int.MAX_VALUE).toInt(), builder.build())
            }
        }
    }

    private fun hasScanPermission(): Boolean =
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S)
            ActivityCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_SCAN) == PackageManager.PERMISSION_GRANTED
        else
            ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
}

/* ========================== UI ========================== */

@Composable
fun ConnectMenu(
    scanning: Boolean,
    devices: List<BluetoothDevice>,
    status: String,
    onScanToggle: () -> Unit,
    onDeviceSelected: (BluetoothDevice) -> Unit
) {
    Column(Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
        Button(onClick = onScanToggle) { Text(if (scanning) "Stop Scan" else "Scan for Devices") }
        Spacer(Modifier.height(12.dp))
        LazyColumn(Modifier.weight(1f)) {
            items(devices) { d ->
                Card(Modifier.fillMaxWidth().padding(vertical = 4.dp).clickable { onDeviceSelected(d) }) {
                    Column(Modifier.padding(12.dp)) { Text(d.name ?: "Unnamed", fontSize = 18.sp); Text(d.address, fontSize = 12.sp) }
                }
            }
        }
        Spacer(Modifier.height(8.dp)); Text(status, fontSize = 14.sp)
    }
}

@Composable
fun LiveChartView(
    rpmHistory: List<Pair<Long, Int>>,
    rpm: Int,
    status: String,
    onFinish: () -> Unit,
    onDisconnect: () -> Unit
) {
    val maxRpm = max(120, rpmHistory.maxOfOrNull { it.second } ?: 0)
    val start = rpmHistory.firstOrNull()?.first ?: 0L
    val end = r
